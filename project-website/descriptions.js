export const description1 = "The DCD above represents the structure of a part of our GreenPlate application, focusing on" 
+ "user interaction with recipes and pantry management. The `User` class contains attributes"
+ "for identification and credentials, along with methods for account management, such as"
+ "signing up, logging in, and updating personal information. It has a one-to-one relationship"
+ "with both the `Pantry` and `Cookbook` classes, denoted by a straight line with the label"
+ "'maintains' pointing to `Pantry` and 'has' to `Cookbook`, each with a multiplicity of one,"
+ "signifying that each user maintains a single pantry and has a single cookbook. The `Pantry`"
+ "class holds a list of ingredients, with methods to add ingredients and retrieve them. It stocks"
+ "multiple `Ingredient` instances, as indicated by the 'stocks' relationship, which has a"
+ "one-to-many cardinality. The `Ingredient` class includes attributes for its name, quantity,"
+ "calories, and expiration date, essential for tracking food items. Lastly, the `Cookbook` class,"
+ "linked to the `Recipe` class by a one-to-many relationship labeled 'has', can hold multiple"
+ "recipes. Each `Recipe` has a unique identifier, a name, and a list of `Ingredients`. The"
+ "`Ingredient` instances are part of recipes, as depicted by the 'contains' relationship, with a"
+ "one-to-many multiplicity indicating that a recipe can contain many ingredients. Our DCD"
+ "encapsulates the core functionality needed for users to manage their recipes and pantry"
+ "within the application."

export const description2 = "Within the ':Controller,' there is an optional (opt) frame indicating that the following process"
+ "occurs conditionally, depending on a certain precondition which is not explicitly stated here."
+ "Inside this optional frame, there's a loop fragment (loop) indicating that the actions inside the"
+ "loop occur for each recipe entry. After processing the recipe entries, the ':Controller'"
+ "attempts to save the recipe by invoking the 'saveRecipe(name, calories) method, passing it"
+ "along to the ':Cookbook' object. The ':Cookbook' has a responsibility to store the recipe,"
+ "denoted by the 'store(recipe)' method call. An alternative fragment (alt) shows two branches"
+ "of execution depending on whether the recipe is successfully saved or not. If the recipe is"
+ "saved successfully, a 'confirmation' message is returned to the ':Controller,' which likely then"
+ "propagates back to the ':UserInterface' and informs the user of success. If there's an error in"
+ "adding the recipe to the cookbook, an 'error' message is returned instead, indicating failure"
+ "to complete the operation"

export const description3 = "This code is a great example of the Single Responsibility Principle (SRP) because it"
+ "deals with a very specific task. In this example, this class is created solely for the"
+ "user to input their meal. As such, it follows a very specific goal and does not have"
+ "any methods or variables outside of that task. This follows the guideline of creating"
+ "many small and specific methods rather than a few large methods."

export const description4 = "This is a great example showcasing the Interface Segregation Principle. In this"
+ "example, the QuantityIngredientsSortingStrategy class only needs a comparator"
+ "method, so it implements SortingStrategy which only comes with a comparator"
+ "method. This ensures that the parent class is is using all of the methods of the"
+ "interface and not implementing it unnecessarily."

export const description5 = "This is an example of the Open-Closed principle because we are showing that we"
+ "can extend the AppCompactActivity to fit many different purposes. In this example,"
+ "we are extending the activity to create a SignUp page but we used it for a login"
+ "activity as well. This shows that we can add functionality by adding more code but"
+ "we are not changing the original code."

export const description6 = "Above is an example of how we utilized the strategy design pattern. The SortingStrategy"
+ "interface defines a contract for all sorting strategies with a single method getComparator(),"
+ "which is supposed to return a Comparator<Recipe> object. The Comparator<Recipe> is an abstraction that can compare two Recipe objects, "
+ "which defines the order between them. As"
+ "seen in the second screenshot, this class is one of the concrete implementations of the"
+ "SortingStrategy interface. It provides the specific logic for sorting based on the number of"
+ "ingredients. The SortingStrategy interface allows the client code to use various sorting"
+ "strategies interchangeably. A client that requires a sorting strategy can be written to accept"
+ "a SortingStrategy object and use its getComparator() method to obtain the necessary"
+ "Comparator<Recipe> without needing to know the details of how the sorting is performed."

export const description7 = "Above, we see a implementation of the Singleton Design Pattern. In the entire runtime of the application, "
+ "we can only have one Shopping List, which contains all the firebase logic."