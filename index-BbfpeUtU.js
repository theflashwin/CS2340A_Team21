(function(){const c=document.createElement("link").relList;if(c&&c.supports&&c.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))l(e);new MutationObserver(e=>{for(const n of e)if(n.type==="childList")for(const h of n.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&l(h)}).observe(document,{childList:!0,subtree:!0});function p(e){const n={};return e.integrity&&(n.integrity=e.integrity),e.referrerPolicy&&(n.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?n.credentials="include":e.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function l(e){if(e.ep)return;e.ep=!0;const n=p(e);fetch(e.href,n)}})();const m="The DCD above represents the structure of a part of our GreenPlate application, focusing onuser interaction with recipes and pantry management. The `User` class contains attributesfor identification and credentials, along with methods for account management, such assigning up, logging in, and updating personal information. It has a one-to-one relationshipwith both the `Pantry` and `Cookbook` classes, denoted by a straight line with the label'maintains' pointing to `Pantry` and 'has' to `Cookbook`, each with a multiplicity of one,signifying that each user maintains a single pantry and has a single cookbook. The `Pantry`class holds a list of ingredients, with methods to add ingredients and retrieve them. It stocksmultiple `Ingredient` instances, as indicated by the 'stocks' relationship, which has aone-to-many cardinality. The `Ingredient` class includes attributes for its name, quantity,calories, and expiration date, essential for tracking food items. Lastly, the `Cookbook` class,linked to the `Recipe` class by a one-to-many relationship labeled 'has', can hold multiplerecipes. Each `Recipe` has a unique identifier, a name, and a list of `Ingredients`. The`Ingredient` instances are part of recipes, as depicted by the 'contains' relationship, with aone-to-many multiplicity indicating that a recipe can contain many ingredients. Our DCDencapsulates the core functionality needed for users to manage their recipes and pantrywithin the application.",u="Within the ':Controller,' there is an optional (opt) frame indicating that the following processoccurs conditionally, depending on a certain precondition which is not explicitly stated here.Inside this optional frame, there's a loop fragment (loop) indicating that the actions inside theloop occur for each recipe entry. After processing the recipe entries, the ':Controller'attempts to save the recipe by invoking the 'saveRecipe(name, calories) method, passing italong to the ':Cookbook' object. The ':Cookbook' has a responsibility to store the recipe,denoted by the 'store(recipe)' method call. An alternative fragment (alt) shows two branchesof execution depending on whether the recipe is successfully saved or not. If the recipe issaved successfully, a 'confirmation' message is returned to the ':Controller,' which likely thenpropagates back to the ':UserInterface' and informs the user of success. If there's an error inadding the recipe to the cookbook, an 'error' message is returned instead, indicating failureto complete the operation",f="This code is a great example of the Single Responsibility Principle (SRP) because itdeals with a very specific task. In this example, this class is created solely for theuser to input their meal. As such, it follows a very specific goal and does not haveany methods or variables outside of that task. This follows the guideline of creatingmany small and specific methods rather than a few large methods.",y="This is a great example showcasing the Interface Segregation Principle. In thisexample, the QuantityIngredientsSortingStrategy class only needs a comparatormethod, so it implements SortingStrategy which only comes with a comparatormethod. This ensures that the parent class is is using all of the methods of theinterface and not implementing it unnecessarily.",b="This is an example of the Open-Closed principle because we are showing that wecan extend the AppCompactActivity to fit many different purposes. In this example,we are extending the activity to create a SignUp page but we used it for a loginactivity as well. This shows that we can add functionality by adding more code butwe are not changing the original code.",w="Above is an example of how we utilized the strategy design pattern. The SortingStrategyinterface defines a contract for all sorting strategies with a single method getComparator(),which is supposed to return a Comparator<Recipe> object. The Comparator<Recipe> is an abstraction that can compare two Recipe objects, which defines the order between them. Asseen in the second screenshot, this class is one of the concrete implementations of theSortingStrategy interface. It provides the specific logic for sorting based on the number ofingredients. The SortingStrategy interface allows the client code to use various sortingstrategies interchangeably. A client that requires a sorting strategy can be written to accepta SortingStrategy object and use its getComparator() method to obtain the necessaryComparator<Recipe> without needing to know the details of how the sorting is performed.",I="Above, we see a implementation of the Singleton Design Pattern. In the entire runtime of the application, we can only have one Shopping List, which contains all the firebase logic.",a=document.getElementById("text-box-title"),s=document.getElementById("text-box-description"),r=document.getElementById("text-box-image"),v=document.getElementById("tab1"),T=document.getElementById("tab2"),k=document.getElementById("tab3"),L=document.getElementById("tab4"),E=document.getElementById("tab5"),x=document.getElementById("tab6"),S=document.getElementById("tab7");v.addEventListener("click",()=>{a.innerHTML="DCD Diagram",s.innerHTML=m,r.src="img/DCD.png"});T.addEventListener("click",()=>{a.innerHTML="Sequence Diagram",s.innerHTML=u,r.src="img/sequence.png"});k.addEventListener("click",()=>{a.innerHTML="Single Responsibility",s.innerHTML=f,r.src="img/single.png"});L.addEventListener("click",()=>{a.innerHTML="Interface Segregation Principle",s.innerHTML=y,r.src="img/segregation.png"});E.addEventListener("click",()=>{a.innerHTML="Open-Closed Principle",s.innerHTML=b,r.src="img/openclosed.png"});x.addEventListener("click",()=>{a.innerHTML="Strategy",s.innerHTML=w,r.src="img/strategy.png"});S.addEventListener("click",()=>{a.innerHTML="Singleton",s.innerHTML=I,r.src="img/singleton.png"});const C=document.getElementById("back-button"),B=document.getElementById("forward-button"),A=document.getElementById("image-box-1"),M=document.getElementById("image-box-2"),H=document.getElementById("image-box-3"),P=document.getElementById("image-box-4"),R=document.getElementById("image-box-5"),D=document.getElementById("image-box-6"),O=document.getElementById("image-box-7"),d=document.getElementById("caption"),q="Once the app has loaded, it brings the user to a convenient log-in screen, which allows the user to log in with a secure email and password or create a new account if needed.",U="After the user successfully logs in, they are brought to the “Input Meal” screen. This screen allows the user to input their meals for the day, which updates the “Total Calories” count below. This screen also displays the user’s personal information, which can be updated in the Update Personal Info tab. Below that, the user’s total calories for the day and calculated goal (based on their personal information) is shown for the user to track their calories effectively. At the bottom of the screen, the user is able to toggle between 2 different visualizations of their calorie counts.",j="Using the navigation bar at the bottom, the user can navigate to the Recipe screen. In this screen, the user can add a Recipe and the Ingredients/Quantities needed to make it. These recipes are saved into a global database that can be viewed by any user. At the bottom of the screen, we see a list of the recipes available. Next to each recipe, the first button is able to open a list of ingredients if the user has the ingredients needed to make the recipe. If the user does not have enough ingredients, they can press the button on the right to add the ingredients to their shopping list so they can buy them.",N="When we open the ingredients screen, we see the recipe name along with the necessary ingredients and their quantities. At the bottom of the screen, we can go back to the Recipe Screen or we can “Cook” the recipe. This will input the meal into the User’s day and take out the ingredients used from the user’s pantry.",z="The next screen is the Ingredients Screen. Here we can input ingredients that the user has in their pantry, along with the quantity, calories, and expiration date. On the bottom half of the screen, the app presents a scrollable list of each ingredient and its quantity. Each ingredient also has a “-” and “+” which allow the user to manually increment or decrement the amount of an ingredient available accordingly.",Q="The next screen is the Shopping List screen. In this screen, users can add items to a shopping list. Using the “Add to Cart” and “Checkout” buttons, the user can buy specified ingredients from the shopping list, which makes them appear in their Pantry.",W="The last screen, as mentioned previously, is the Update Personal Information screen. This screen allows the user to input / update their personal information whenever needed to accommodate fluctuations in their health.";let i=0;const o=[A,M,H,P,R,D,O],g=[q,U,j,N,z,Q,W];C.addEventListener("click",()=>{i=(i-1)%o.length,i==-1&&(i=4);for(let t=0;t<o.length;t++)t==i?o[t].setAttribute("class","duration-700 ease-in-out"):o[t].setAttribute("class","hidden duration-700 ease-in-out"),d.innerHTML=g[i]});B.addEventListener("click",()=>{i=(i+1)%o.length;for(let t=0;t<o.length;t++)t==i?o[t].setAttribute("class","duration-700 ease-in-out"):o[t].setAttribute("class","hidden duration-700 ease-in-out");d.innerHTML=g[i]});
